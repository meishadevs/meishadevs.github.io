---
title: 深拷贝与浅拷贝
categories:
  - JavaScript
  - ES6
tags:
  - JavaScript
  - ES6
date: 2020-08-31 20:07:21
---
在平时的开发中使用深拷贝与浅拷贝的场景还是挺多的，比如从 api 接口中获取到请求的结果后，我们通常将请求结果通过浅拷贝的形式赋值给一个对象或数组。
<!--more-->

### 浅拷贝
假定我们有一个这样的需求，给定一个对象 obj，需要将对象 obj 分别赋值给 clone1，clone2，代码实现如下

    let obj = {
      a: 123
    }
    
    let clone1 = obj
    let clone2 = obj

当将 clone1.a 的属性值改成 456 时，会发现 clone2.a 的属性值和 obj.a 的属性值都变成了 456，这是因为当使用等于号直接赋值时，clone1，clone2 中实际上保存都是对象 obj 的地址，当修改 clone1 对象中 a 属性的值时，实际上修改的是 obj.a 的值

    let obj = {
      a: 123
    };
    
    let clone1 = obj;
    let clone2 = obj;
    
    clone1.a = 456;
    
    console.log('obj.a:', obj.a);
    console.log('clone1.a:', clone1.a);
    console.log('clone2.a:', clone2.a);

执行结果
{% img blog-image /images/2020083101.png %}

#### 使用对象展开运算符实现浅拷贝
我们将上面的代码改成使用对象展开运算符实现的浅拷贝的形式后，发现当改变 clone1.a 的值后，obj.a，clone2.a 的值都没发生变化，因为改成浅拷贝的形式实际上只是对象的拷贝，没有拷贝地址

    let obj = {
      a: 123
    };
    
    let clone1 = {
      ...obj
    };
    
    let clone2 = {
      ...obj
    };
    
    clone1.a = 456;
    
    console.log('obj.a:', obj.a);
    console.log('clone1.a:', clone1.a);
    console.log('clone2.a:', clone2.a);

执行结果
{% img blog-image /images/2020083102.png %}
    
#### 使用 Object.assign 实现浅拷贝

    let obj = {
      a: 123
    };
    
    let clone1 = Object.assign({}, obj);
    let clone2 = Object.assign({}, obj);
    
    clone1.a = 456;
    
    console.log('obj.a:', obj.a);
    console.log('clone1.a:', clone1.a);
    console.log('clone2.a:', clone2.a);

执行结果
{% img blog-image /images/2020083102.png %}

#### 使用 Object.key 实现浅拷贝

    let obj = {
      a: 123
    };
    
    let clone1 = Object.keys(obj).reduce((res, cur) => ({...res, [cur]: obj[cur]}), {})
    let clone2 = Object.keys(obj).reduce((res, cur) => ({...res, [cur]: obj[cur]}), {})
    
    clone1.a = 456;
    
    console.log('obj.a:', obj.a);
    console.log('clone1.a:', clone1.a);
    console.log('clone2.a:', clone2.a);

执行结果
{% img blog-image /images/2020083102.png %}

#### 使用 for 循环遍历对象的方式实现浅拷贝

    let obj = {
      a: 123
    };
    
    let clone1 = {};
    let clone2 = {};
    
    for(let key in obj) {
      clone1[key] = obj[key]
    }
    
    for(let key in obj) {
      clone2[key] = obj[key]
    }
    
    clone1.a = 456;
    
    console.log('obj.a:', obj.a);
    console.log('clone1.a:', clone1.a);
    console.log('clone2.a:', clone2.a);

执行结果
{% img blog-image /images/2020083102.png %}

### 深拷贝

在使用深拷贝之前，我们也假定一个场景，例如要对下面这个比较复杂的对象进行拷贝时，这个对象比较复杂，对象的属性即有对象，也有数组，还有 Set 类型的数据



> meishadevs欢迎任何形式的转载，但请务必注明出处，尊重他人劳动成果。
转载请注明： 【文章转载自meishadevs：[]()】